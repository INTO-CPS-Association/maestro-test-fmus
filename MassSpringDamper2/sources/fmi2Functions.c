/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  src\fmi2Functions.c
 *  model: MassSpringDamper
 *  expmt: MassSpringDamper
 *  date:  April 3, 2017
 *  time:  11:26:43 AM
 *  user:  INTO-CPS
 *  from:  20-sim 4.6 Professional Single
 *  build: 4.6.3.7711
 **********************************************************/

/* This file contains the implementation of the FMI functions
   Please check the fmiSunctions.h file for more details
*/

#if !defined FMI2_FUNCTION_PREFIX && !defined NO_FUNCTION_PREFIX
#define FMI2_FUNCTION_PREFIX MassSpringDamper2_
#endif

/* The FMI related headers */
#include "fmi2Functions.h"
#include "fmiGUID.h"

/* Our own include files */
#include "xxmodel.h"
#include "xxsubmod.h"

/* The system include files */
#include <string.h>
#include <ctype.h>

/* make a FMI_Dll_Export that is for both FMI1 and FMI2 */
#define FMI_Dll_Export FMI2_Export

#if defined WIN32 || defined WIN64
static const char native_path_separator = '\\';
static const char foreign_path_separator = '/';
#else
static const char native_path_separator = '/';
static const char foreign_path_separator = '\\';
#endif

/**
 * Convert an uri provided by the the co-simulator to a native path
 * @param uri Input path. native and file:/ and file:/// uri's right now
 * @return Natve path that ends with a path separator.
 * Note that the caller is responsible for free-ing the allocated string buffer
 * memory
 */
const char* URIToNativePath(xx_ModelInstance* model_instance, const char* uri)
{
	unsigned int path_start = 0;
	char* path = NULL;
	unsigned int path_len = 0;
	unsigned int uri_len = 0;
	unsigned int i = 0;
	unsigned int j = 0;
	char buf[3] = "00";

	if (!uri || model_instance == NULL)
	{
		return NULL;
	}

	uri_len = (unsigned int) strlen(uri);

	if (uri_len == 0)
	{
		return NULL;
	}

	/* Check if we got a file:/// uri */
	if (strncmp(uri, "file:///", 8) == 0)
	{
		if (uri[9] == ':')
		{
			/* Windows drive letter in the URI (e.g. file:///c:/ uri */
			/* Remove the file:/// */
			path_start = 8;
		}
		else
		{
			/* Remove the file:// but keep the third / */
			path_start = 7;
		}
	}
#if defined WIN32 || defined WIN64
	/* Check if we got a file://hostname/path uri */
	else if (strncmp(uri, "file://", 7) == 0)
	{
		/* Convert to a network share path: //hostname/path */
		path_start = 5;
	}
#endif
	/* Check if we got a file:/ uri */
	else if (strncmp(uri, "file:/", 6) == 0)
	{
		if (uri[7] == ':')
		{
			/* Windows drive letter in the URI (e.g. file:/c:/ uri */
			/* Remove the file:/ */
			path_start = 6;
		}
		else
		{
			/* Remove the file: but keep the / */
			path_start = 5;
		}
	}
	/* Assume that it is a native path */
	else
	{
		path_start = 0;
	}

	/* Check the length of the remaining string */
	path_len = (int)strlen(&uri[path_start]);
	if (path_len == 0)
	{
		return NULL;
	}

	/* Allocate memory for the return value including terminating \0 and extra path separator */
	if ((model_instance->fmiCallbackFunctions) &&( model_instance->fmiCallbackFunctions->allocateMemory != NULL))
	{
		path = (char*) model_instance->fmiCallbackFunctions->allocateMemory(path_len + 2, sizeof(char));
	}
	else
	{
		path = (char*) malloc(path_len + 2);
	}

	/* Copy the remainder of the uri and replace all percent encoded character
	* by their ASCII character and translate slashes to backslashes on Windows
	* and backslashes to slashes on other OSses
	*/
	for (i = path_start, j = 0; i < uri_len; i++, j++)
	{
		if (uri[i] == '%')
		{
			/* Replace the precent-encoded hexadecimal digits by its US-ASCII
			* representation */
			if (i < uri_len - 2)
			{
				if ((isxdigit(uri[i + 1])) && (isxdigit(uri[i + 2])))
				{
					strncpy(buf, uri + i + 1, 2);
					path[j] = (unsigned char)strtol(buf, NULL, 16);
					i += 2;
					path_len -= 2;
				}
				else
				{
					/* Not percent encoded, keep the % */
					path[j] = uri[i];
				}
			}
			else
			{
				/* Not percent encoded, keep the % */
				path[j] = uri[i];
			}
		}
		else if (uri[i] == foreign_path_separator)
		{
			/* Translate slashes to backslashes on Windows and backslashes to slashes on other OSses */
			path[j] = native_path_separator;
		}
		else
		{
			/* Just copy the character */
			path[j] = uri[i];
		}
	}

	/* Check if we need to add a path separator at the end */
	if (path[path_len - 1] == native_path_separator)
	{
		path[path_len] = '\0';
	}
	else
	{
		path[path_len] = native_path_separator;
	}
	/* Make sure that the string is always NULL terminated */
	path[path_len + 1] = '\0';

	return path;
}

/* Inquire version numbers of header files */
FMI_Dll_Export const char* fmi2GetTypesPlatform()
{
	return fmi2TypesPlatform;
}
FMI_Dll_Export const char* fmi2GetVersion()
{
	return fmi2Version;
}
FMI_Dll_Export fmi2Status fmi2SetDebugLogging  (fmi2Component c, fmi2Boolean loggingOn,
											size_t nCategories,
											const fmi2String categories[])
{
	return fmi2OK;       /* not yet */
}
/* Data Exchange Functions*/
FMI_Dll_Export fmi2Status fmi2GetReal(fmi2Component c,
									 const fmi2ValueReference vr[],
									 size_t nvr, fmi2Real value[])
{
	size_t i;
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	for (i = 0; i < nvr; i++)
	{
		value [i] = model_instance->MEMORY[ vr[i] ];
	}
	return fmi2OK;
}
FMI_Dll_Export fmi2Status fmi2GetInteger(fmi2Component c,
								const fmi2ValueReference vr[],
								size_t nvr,
								fmi2Integer value[])
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	/* 20-sim generated C-code uses doubles for the model equation calculations.
	   The variable type (i.e. integer or boolean) are not supported as data type,
	   but are transfered to doubles. In the FMI interface however, the double 
	   can be converted to its implicit type  */
	size_t i;
	for (i = 0; i < nvr; i++)
	{
		value [i] = (fmi2Integer) model_instance->MEMORY[ vr[i] ];
	}
	return fmi2OK;
}
FMI_Dll_Export fmi2Status fmi2GetBoolean(fmi2Component c,
								const fmi2ValueReference vr[],
								size_t nvr,
								fmi2Boolean value[])
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	/* 20-sim generated C-code uses doubles for the model equation calculations.
	   The variable type (i.e. integer or boolean) are not supported as data type,
	   but are transfered to doubles. In the FMI interface however, the double
	   can be converted to its implicit type  */

	size_t i;
	for (i = 0; i < nvr; i++)
	{
		value [i] = (model_instance->MEMORY[ vr[i] ] == 1.0);
	}
	return fmi2OK;
}
FMI_Dll_Export fmi2Status fmi2GetString(fmi2Component c,
								const fmi2ValueReference vr[],
								size_t nvr,
								fmi2String value[])
{
	return fmi2Error;    /* not yet */
}

FMI_Dll_Export fmi2Status fmi2SetReal(fmi2Component c,
								const fmi2ValueReference vr[],
								size_t nvr,
								const fmi2Real value[])
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;
	size_t i;
	for (i = 0; i < nvr; i++)
	{
		model_instance->MEMORY[ vr[i] ] = value [i];
	}
	return fmi2OK;
}

FMI_Dll_Export fmi2Status fmi2SetInteger (fmi2Component c,
								const fmi2ValueReference vr[],
								size_t nvr,
								const fmi2Integer value[])
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	/* 20-sim generated C-code uses doubles for the model equation calculations.
	   The variable type (i.e. integer or boolean) are not supported as data type,
	   but are transfered to doubles. In the FMI interface however, the double
	   can be converted to its implicit type  */
	size_t i;
	for (i = 0; i < nvr; i++)
	{
		model_instance->MEMORY[ vr[i] ] = (XXDouble) value [i];
	}
	return fmi2OK;
}
FMI_Dll_Export fmi2Status fmi2SetBoolean(fmi2Component c,
								const fmi2ValueReference vr[],
								size_t nvr,
								const fmi2Boolean value[])
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;
	/* temp implementation allowing boolean to real conversion, until proper boolean support is added. */
	size_t i;
	for (i = 0; i < nvr; i++)
	{
		model_instance->MEMORY[vr[i]] = value[i] ? 1.0 : 0.0;
	}
	return fmi2OK;    
}
FMI_Dll_Export fmi2Status fmi2SetString(fmi2Component c,
								const fmi2ValueReference vr[],
								size_t nvr,
								const fmi2String  value[])
{
	return fmi2Error;   /* not yet */
}

fmi2Component fmi2Instantiate(fmi2String instanceName,
								fmi2Type fmuType,
								fmi2String fmuGUID,
								fmi2String fmuResourceLocation,
								const fmi2CallbackFunctions* functions,
								fmi2Boolean visible,
								fmi2Boolean loggingOn)
{
	xx_ModelInstance* model_instance = NULL;
	int offset = 0;

	/* we should remember the functions pointer in order to make callback functions */
	if (!functions)
	{
		return NULL; // we cannot even log this problem
	}
	
	if (!functions->logger)
	{
		return NULL; // we cannot even log this problem
	}
	if (!instanceName || strlen(instanceName)==0)
	{
		functions->logger(NULL, "?", fmi2Error, "error",
				"Missing instance name.");
		return NULL;
	}
	if (!functions->allocateMemory || !functions->freeMemory) {
		functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
				"fmi2Instantiate: Missing memory callback function.");
		return NULL;
	}
	/* Check whether the given GUID equals our GUID */
	if (!fmuGUID || strlen(fmuGUID) == 0) {
		functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
				"fmi2Instantiate: Missing GUID.");
		return NULL;
	}
	if( strncmp(fmuGUID, FMI_GUID, strlen(fmuGUID)) != 0 )
	{
		functions->logger(NULL, instanceName, fmi2Error, "error",
			"fmi2Instantiate: Wrong GUID %s. Expected %s.", fmuGUID, FMI_GUID);
		return NULL;
	}
	
	model_instance = (xx_ModelInstance *)functions->allocateMemory(1, sizeof(xx_ModelInstance));

	if(!model_instance)
	{
		functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
			"fmi2Instantiate: Out of memory while allocating model instance");
		return NULL;
	}

	memset(model_instance, 0, sizeof(xx_ModelInstance));
	
	model_instance->instanceName = (fmi2String) functions->allocateMemory(1 + strlen(instanceName), sizeof(char));

	if (!model_instance->instanceName)
	{
		functions->logger(functions->componentEnvironment, instanceName, fmi2Error, "error",
			"fmi2Instantiate: Out of memory while allocating instance name");
		return NULL;
	}
	strcpy((char *)model_instance->instanceName, (char *)instanceName);
	
	/* Prepare the model instance struct */
	model_instance->start_time = 0.0;
	model_instance->finish_time = 0.0;
	model_instance->m_use_finish_time = XXFALSE;
	model_instance->step_size = 0.01;
	model_instance->time = 0.0;
	model_instance->steps = 0;
	model_instance->initialize = XXTRUE;
	model_instance->major = XXTRUE;
	model_instance->stop_simulation = XXFALSE;

	/* Set the offsets within the model_instance->MEMORY array */
	model_instance->P = &model_instance->MEMORY[offset];	/* parameters offset */
	offset = offset + xx_parameter_count;
	model_instance->I = &model_instance->MEMORY[offset];		/* initial values offset */
	offset = offset + xx_initialvalue_count;
	model_instance->V = &model_instance->MEMORY[offset];		/* variables offset */
	offset = offset + xx_variable_count;
	model_instance->s = &model_instance->MEMORY[offset];		/* states offset */
	offset = offset + xx_state_count;
	model_instance->R = &model_instance->MEMORY[offset];		/* rates offset */
	offset = offset + xx_state_count;
	
	/* Register the callback */
	model_instance->fmiCallbackFunctions = functions;
	/* Remember the resource folder location */
	model_instance->resourceLocation = URIToNativePath(model_instance, fmuResourceLocation);
	
	/* check if we are setup for co-simulation, that's the only possible option for now */
	if( fmuType != fmi2CoSimulation )
	{
		model_instance->fmiCallbackFunctions->logger(NULL, instanceName, fmi2Error, "error",
			"FMU can only be used for Co-Simulation, not for Model Exchange");
		return NULL;
	}

	return (fmi2Component) model_instance;
}
fmi2Status fmi2SetupExperiment(fmi2Component c,
							fmi2Boolean toleranceDefined,
							fmi2Real tolerance,
							fmi2Real startTime,
							fmi2Boolean stopTimeDefined,
							fmi2Real stopTime)
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	/* copy the arguments */
	model_instance->start_time = startTime;
	if (stopTimeDefined == fmi2True)
	{
		model_instance->finish_time = stopTime;
		model_instance->m_use_finish_time = XXTRUE;
	}

	/* Initialize our data arrays */
	XXModelInitialize(model_instance);

	/* all done */
	return fmi2OK;
}
fmi2Status fmi2EnterInitializationMode(fmi2Component c)
{
	/* nothing to do for now */
	return fmi2OK;
}
fmi2Status fmi2ExitInitializationMode(fmi2Component c)
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	/* Initialize the submodel itself */
	XXInitializeSubmodel (model_instance);

	return fmi2OK;
}
fmi2Status fmi2Terminate(fmi2Component c) 
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	/* Perform the final calculations */
	XXTerminateSubmodel (model_instance, model_instance->time);

	/* all done */
	return fmi2OK;
}
fmi2Status fmi2Reset(fmi2Component c) 
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	/* initialize the submodel itself */
	XXInitializeSubmodel (model_instance);

	/* all done */
	return fmi2OK;
}

void fmi2FreeInstance(fmi2Component c)
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;
	const fmi2CallbackFunctions* fmiCallbackFunctions = model_instance->fmiCallbackFunctions;

	if (model_instance->resourceLocation != NULL)
	{
		model_instance->fmiCallbackFunctions->freeMemory((void*)model_instance->resourceLocation);
		model_instance->resourceLocation = NULL;
	}

	if(model_instance->instanceName != NULL)
	{
		model_instance->fmiCallbackFunctions->freeMemory((void *)model_instance->instanceName);
		model_instance->instanceName = NULL;
	}

	/* Copy the callback functions before freeing the model_instance */
	fmiCallbackFunctions->freeMemory((void *) model_instance);
	model_instance =  NULL;
}

fmi2Status fmi2SetRealInputDerivatives(fmi2Component c,
									const fmi2ValueReference vr[], size_t nvr,
									const fmi2Integer order[],
									const fmi2Real value[]) 
{
    /* not yet */
    return fmi2Error;
}

fmi2Status fmi2GetRealOutputDerivatives(fmi2Component c,
									const fmi2ValueReference vr[],
									size_t nvr,
									const fmi2Integer order[],
									fmi2Real value[]) 
{
	/* not yet */
	return fmi2Error;
}

fmi2Status fmi2CancelStep(fmi2Component c) 
{
	/* not yet */
	return fmi2Error;
}

fmi2Status fmi2DoStep(fmi2Component c,
					fmi2Real currentCommunicationPoint,
					fmi2Real communicationStepSize,
					fmi2Boolean noSetFMUStatePriorToCurrentPoint)
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	/* Treat also case of zero step, i.e. during an event iteration */
	if (communicationStepSize == 0)
	{
		return fmi2OK;
	}

	/* as long as we are not passed our communication point */
	while (model_instance->time < (currentCommunicationPoint + communicationStepSize))
	{
		/* check for termination first */
		if ( model_instance->m_use_finish_time && (model_instance->time > model_instance->finish_time) )
		{
			if(model_instance->fmiCallbackFunctions != NULL && model_instance->fmiCallbackFunctions->logger != NULL)
			{
				model_instance->fmiCallbackFunctions->logger(NULL, "MassSpringDamper2", fmi2Error, "error",
					"Exceeded model finish time: %g > %g\n", model_instance->time, model_instance->finish_time);
			}
			
			/* we're done */
			return fmi2Error;
		}
		/* Check for stop simulation */
		if (model_instance->stop_simulation == XXTRUE)
		{
			return fmi2Error;
		}

		/* Call the submodel to calculate the output, and increase the time as well */
		XXCalculateSubmodel (model_instance, model_instance->time);
	}

	/* for now */
	return fmi2OK;
}

fmi2Status fmi2GetStatus(fmi2Component c, const fmi2StatusKind s, fmi2Status* value) 
{
	/* all fine? */
	return fmi2OK;
}

fmi2Status fmi2GetRealStatus(fmi2Component c, const fmi2StatusKind s, fmi2Real* value)
{
	/* all fine? */
	return fmi2OK;
}

fmi2Status fmi2GetIntegerStatus(fmi2Component c, const fmi2StatusKind s, fmi2Integer* value)
{
	/* all fine? */
	return fmi2OK;
}

fmi2Status fmi2GetBooleanStatus(fmi2Component c, const fmi2StatusKind s, fmi2Boolean* value)
{
	/* all fine? */
	return fmi2OK;
}

fmi2Status fmi2GetStringStatus(fmi2Component c, const fmi2StatusKind s, fmi2String*  value)
{
	/* not yet */
	return fmi2Discard;
}

fmi2Status fmi2GetContinuousStates(fmi2Component c, fmi2Real x[], size_t nx)
{
	size_t i;
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;

	if( 2 != nx )
	{
		return fmi2Error;
	}

	for( i = 0; i < 2; ++i)
	{
		x[i] = model_instance->s[i];
	}
	return fmi2OK;
}

fmi2Status fmi2GetFMUstate (fmi2Component c, fmi2FMUstate* FMUstate)
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;
	if (FMUstate == NULL)
		// We cannot store our memory pointer
		return fmi2Discard;

	if (*FMUstate == NULL)
	{
		// Allocate a new FMUstate block
		*FMUstate = (fmi2FMUstate) model_instance->fmiCallbackFunctions->allocateMemory(sizeof(xx_ModelInstance), sizeof(char));
	}
	if (*FMUstate == NULL)
	{
		// We have no destination memory
		model_instance->fmiCallbackFunctions->logger(c, model_instance->instanceName, fmi2Error, "error", "Could not allocate memory for fmi2GetFMUstate.");
		return fmi2Error;
	}

	// There is no way to check that the passed FMUstate (void*) refers to a valid memory block of the correct size
	// The assumption here is that it is valid and correctly sized when non-NULL
	memcpy(*FMUstate, (const void*) model_instance, sizeof(xx_ModelInstance));

	return fmi2OK;
}

fmi2Status fmi2SetFMUstate (fmi2Component c, fmi2FMUstate FMUstate)
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;
	xx_ModelInstance* stored_state = (xx_ModelInstance*) FMUstate;

	if (FMUstate == NULL)
	{
		// We have no stored state
		model_instance->fmiCallbackFunctions->logger(c, model_instance->instanceName, fmi2Error, "error", "Could not restore the FMU state.");
		return fmi2Error;
	}

	/* Selective restore of the state items */
	/* Restore our arrays */
	memcpy(&model_instance->MEMORY, &stored_state->MEMORY, sizeof(model_instance->MEMORY));
	/* Restore the time */
	model_instance->start_time = stored_state->start_time;
	model_instance->finish_time = stored_state->finish_time;
	model_instance->m_use_finish_time = stored_state->m_use_finish_time;
	model_instance->step_size = stored_state->step_size;
	model_instance->time = stored_state->time;
	model_instance->steps = stored_state->steps;
	model_instance->initialize = stored_state->initialize;
	model_instance->major = stored_state->major;
	model_instance->stop_simulation = stored_state->stop_simulation;

	return fmi2OK;
}

fmi2Status fmi2FreeFMUstate(fmi2Component c, fmi2FMUstate* FMUstate)
{
	xx_ModelInstance* model_instance = (xx_ModelInstance*) c;
	if ((FMUstate != NULL) && (*FMUstate != NULL))
	{
		model_instance->fmiCallbackFunctions->freeMemory(*FMUstate);
		*FMUstate = NULL;
	}
	return fmi2OK;
}

fmi2Status fmi2SerializedFMUstateSize(fmi2Component c, fmi2FMUstate FMUstate, size_t *size)
{
	/* not yet */
	return fmi2Discard;
}

fmi2Status fmi2SerializeFMUstate (fmi2Component c, fmi2FMUstate FMUstate, fmi2Byte serializedState[], size_t size)
{
	/* not yet */
	return fmi2Discard;
}

fmi2Status fmi2DeSerializeFMUstate (fmi2Component c, const fmi2Byte serializedState[], size_t size,
                                    fmi2FMUstate* FMUstate)
{
	/* not yet */
	return fmi2Discard;
}

fmi2Status fmi2GetDirectionalDerivative(fmi2Component c, const fmi2ValueReference vUnknown_ref[], size_t nUnknown,
                                        const fmi2ValueReference vKnown_ref[] , size_t nKnown,
                                        const fmi2Real dvKnown[], fmi2Real dvUnknown[])
{
	/* not yet */
	return fmi2Discard;
}
